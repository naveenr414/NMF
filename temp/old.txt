from scipy.sparse import csgraph
import random
from copy import deepcopy

def D(X,lamb):
    U,s,V = np.linalg.svd(X)
    for i in range(len(s)):
        s[i] = max(0,s[i]-lamb)
    
    sig = np.zeros((U.shape[1],V.shape[0]))
    for i in range(len(s)):
        sig[i][i] = s[i]
    
    return U.dot(sig).dot(V)

def grad(X,Q,Y,L,lambOne,sigma):
    d,n = X.shape
    r = np.zeros((d,n))
    for i,j in sigma:
        e = np.zeros((n,1))
        e[j] = 1
        scalar = 2*(Q[:,[i]].T.dot(X[:,[j]]) - Y[i][j])
        r+=scalar*(Q[:,[i]]).dot(e.T)
        
    r+=2*lambOne*Q.dot(Q.T).dot(X).dot(L)
    return r

def g(X,Q,Y,L,lambOne,sigma):
    I = np.zeros(Y.shape)
    for i,j in sigma:
        I[i,j] = 1
    m = np.linalg.norm(I - Q.T.dot(X),ord='fro')**2
    m+=lambOne*np.trace(Q.T.dot(X).dot(L).dot(X.T).dot(Q))
    return m
        
def h(X,Q,Y,L,lambOne,lambTwo,sigma):
    return g(X,Q,Y,L,lambOne,sigma) + lambTwo*np.linalg.norm(X,ord='nuc')

def Gp(X,Q,Y,L,lambOne,lambTwo,Xk1,rhok1,sigma):
    m = np.linalg.norm(X-(Xk1 - 1/(rhok1)*grad(Xk1,Q,Y,L,lambOne,sigma)),ord='fro')**2
    m*=rhok1/2
    m+=lambTwo*np.linalg.norm(X,ord='nuc')
    return m
    
def matrixComplete(W,k,lambOne,lambTwo,sigma,rhoK1=1000,gamma=100):    
    percent = .05
    epsilon = 1
    Q = GNMF(allData.T,W,0,n_components=k,tol=1e-4,max_iter=100,verbose=False)[0]
    Q = Q.T
    sigma = [(j,i) for i,j in sigma]
    L = csgraph.laplacian(W, normed=False)
    Y = deepcopy(allData).T
    notSigma = [(i,j) for i in range(Y.shape[0]) for j in range(Y.shape[1]) if (i,j) not in sigma]
    for i,j in notSigma:
        Y[i][j] = -1
    
    
    rhoK = rhoK1
    Xk1 = np.random.rand(Q.shape[0],allData.shape[0])
    Xk = Xk1
    start = True
    
    previous = np.zeros(Xk.shape)
    
    for i in range(10):
        start = False
        Xk = D(Xk1 - 1/(rhoK1)*grad(Xk1,Q,Y,L,lambOne,sigma),lambTwo/rhoK1)
        rhoK = rhoK1
        l = h(Xk,Q,Y,L,lambOne,lambTwo,sigma)
        r = Gp(Xk,Q,Y,L,lambOne,lambTwo,Xk1,rhoK,sigma)
        while(l>r):
            rhoK*=gamma
            l = h(Xk,Q,Y,L,lambOne,lambTwo,sigma)
            r = Gp(Xk,Q,Y,L,lambOne,lambTwo,Xk1,rhoK,sigma)

        previous = Xk1
        
        Xk1 = deepcopy(Xk)
        rhoK1 = deepcopy(rhoK)

    return Q,Xk
         

    